// Generated by CoffeeScript 1.9.3
(function() {
  "use strict";
  var Card, Deck, Dict, Events, Stack, When, _,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  Dict = require('collections/dict');

  Stack = require('./stack');

  Card = require('./card');

  Events = require('./events');

  When = require('when');

  Deck = (function(superClass) {
    extend(Deck, superClass);

    function Deck(options) {
      this.will_replace = bind(this.will_replace, this);
      this.will_clear = bind(this.will_clear, this);
      this.will_drop = bind(this.will_drop, this);
      this.will_pop = bind(this.will_pop, this);
      this.will_push = bind(this.will_push, this);
      options = options || {};
      this.options = _.defaults({}, options, Deck.defaults);
      this.name = this.options.name;
      this.base = this.options.base;
      this.stack = new Stack();
      this.cards_by_id = new Dict();
      this.cards_in_order = [];
      this.seen = new Dict();
      this.on('replace', this.will_replace);
      this.on('push', this.will_push);
      this.on('pop', this.will_pop);
      this.on('drop', this.will_drop);
      this.on('clear', this.will_clear);
      this.on('all', (function(_this) {
        return function() {
          var args, event;
          event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return console.debug.apply(console, ["*" + event + "* event on " + _this.options.name + ":"].concat(slice.call(args)));
        };
      })(this));
    }

    Deck.prototype.card = function(id, data) {
      return this.add_card(new Card({
        id: id,
        deck: this,
        data: data
      }));
    };

    Deck.prototype.add_card = function(card) {
      card.index = this.cards_in_order.length;
      this.cards_by_id.set(card.id.toLowerCase(), card);
      this.cards_in_order.push(card);
      this.will_trigger('card:add', card);
      return card;
    };

    Deck.prototype.get_card_after = function(card_id) {
      var current;
      current = this.stack.peek();
      return this.cards_in_order[current.index + 1];
    };

    Deck.prototype.will_get_card = When.lift(function(card_id) {
      var card, data;
      if (card_id === '-->') {
        card = this.get_card_after(card_id);
        card_id = card.id;
      } else {
        card = this.cards_by_id.get(card_id.toLowerCase());
      }
      if (!card) {
        data = {};
        return this.will_trigger('card:missing', data).then((function(_this) {
          return function() {
            if (_.isEmpty(data)) {
              throw new Error("No such card " + card_id);
            } else {
              return new Card(data);
            }
          };
        })(this));
      } else {
        return card;
      }
    });

    Deck.prototype.mark_seen = function(card) {
      var seen;
      seen = this.seen.get(card.id);
      this.seen.set(card.id, !seen ? 1 : seen + 1);
      return this.will_trigger('seen', card);
    };

    Deck.prototype.will_push = function(data) {
      var card;
      if (_.isString(data)) {
        data = {
          target: data
        };
      }
      card = data.target;
      if (_.isString(card)) {
        card = this.will_get_card(card);
      }
      return When(card).then((function(_this) {
        return function(card) {
          return _this.stack.will_push(card, data).then(function() {
            _this.mark_seen(card);
            return card;
          });
        };
      })(this));
    };

    Deck.prototype.will_pop = function(data) {
      return this.stack.will_pop(data);
    };

    Deck.prototype.will_drop = function(data) {
      return When(data.from_card).then((function(_this) {
        return function(card) {
          return _this.stack.will_drop(data.from_card, data);
        };
      })(this));
    };

    Deck.prototype.will_clear = function(data) {
      return this.stack.will_clear(data).then((function(_this) {
        return function() {
          return _this.will_push(data);
        };
      })(this));
    };

    Deck.prototype.will_replace = function(data) {
      return this.will_pop(data).then((function(_this) {
        return function(popped) {
          var card;
          card = _this.will_push(data);
          return _this.stack.will_trigger('replaced', popped, card, data).then(function() {
            return [popped, card];
          });
        };
      })(this));
    };

    Deck.prototype.extend = function(extensions) {
      _.extend(this, extensions);
      return this;
    };

    Deck.prototype.broadcast = function() {
      var args, deck, event, i, len, ref, ref1, results;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      (ref = this.base).will_trigger.apply(ref, [event].concat(slice.call(args)));
      ref1 = this.base.decks.all();
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        deck = ref1[i];
        if (deck === !this) {
          results.push(deck.will_trigger.apply(deck, [event].concat(slice.call(args))));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Deck.prototype.send_to_deck = function() {
      var args, deck_id, event, ref;
      deck_id = arguments[0], event = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      return (ref = this.base.decks.get(deck_id)).will_trigger.apply(ref, [event].concat(slice.call(args)));
    };

    return Deck;

  })(Events);

  Deck.defaults = {
    begin_card: 'begin'
  };

  Deck.extend = function(extensions) {
    return _.extend(Deck.prototype, extensions);
  };

  Deck.extend_defaults = function(extensions) {
    return Deck.defaults = _.defaults({}, extensions, Deck.defaults);
  };

  module.exports = Deck;

}).call(this);

//# sourceMappingURL=deck.js.map
